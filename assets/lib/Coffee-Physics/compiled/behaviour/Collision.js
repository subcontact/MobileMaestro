// Generated by CoffeeScript 1.6.2
/* Collision Behaviour
*/

var Collision,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collision = (function(_super) {
  'use strict';
  var QuadTree;
  __extends(Collision, _super);

  function Collision(useMass, width, height) {
    this.useMass = useMass != null ? useMass : true;
    this.allPoints = [];
    this.width = width;
    this.height = height;
    this.pool = new QuadTree(0, 0, 0, width, height);
    this._delta = new Vector();
    this._inverseNormalDelta1 = new Vector();
    this._inverseNormalDelta2 = new Vector();
    Collision.__super__.constructor.apply(this, arguments);
  }

  Collision.prototype.add = function(p) {
    this.allPoints.push(p);
    this.pool.insert(p);
  }

  Collision.prototype.empty = function() {
    this.allPoints = [];
    this.pool.clear();
  }

  Collision.prototype.updatePool = function(){
    this.pool.clear();
    for(var i = 0, length = this.allPoints.length; i < length; i++){
      this.pool.insert(this.allPoints[i]);
    }
  }

  Collision.prototype.apply = function(p, dt, index) {
    //var dist, distSq, mt, o, overlap, r1, r2, radii, _i, _len, _ref, _results;
    var _len, _i, distSq, dist, radii, overlap, o, r1;

    //_ref = this.pool.slice(this.pool.indexOf(p));
    //_results = [];
    var pRadius = p.radius;
    var pPos = p.pos;
    var thisDelta = this._delta;
    var pool = this.pool.retrieve([], p);
    for (_i = 0, _len = pool.length; _i < _len; _i++) {
      o = pool[_i];
      if (!(o !== p)) {
        continue;
      }
      thisDelta.copy(o.pos).sub(pPos);
      distSq = thisDelta.magSq();
      radii = pRadius + o.radius;
      if (distSq <= radii * radii) {
        dist = Math.sqrt(distSq);
        overlap = radii - dist;
        //overlap += 0.05;
        //mt = p.mass + o.mass;
        //r1 = this.useMass ? o.mass / (p.mass + o.mass) : 0.5;
        r1 = o.mass / (p.mass + o.mass);
        //r2 = this.useMass ? p.mass / mt : 0.5;
        this._inverseNormalDelta1.copy(thisDelta).norm();

        pPos.add(this._inverseNormalDelta2.copy(this._inverseNormalDelta1).scale(overlap * -r1));
        o.pos.add(this._inverseNormalDelta2.copy(this._inverseNormalDelta1).scale(overlap * (1 - r1)));
      }
    }
  };
  
  QuadTree = (function(){
    var MAX_OBJECTS = 5;
    var MAX_LEVELS = 100;
    function QuadTree(level, x, y, width, height){
      this.level = level;
      this.objects = {};
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.nodes = new Array(4);
    }

    QuadTree.prototype = {
      level : 0,
      objects : null,
      count : 0,
      nodes : null,
      clear : function(){
        this.objects = {};
        this.count = 0;
        for(var i = 0, length = this.nodes.length; i < length; i++){
          if(this.nodes[i]){
            this.nodes[i].clear();
            this.nodes[i] = null;
          }
        }
      },
      split : function(){
        var subWidth = this.width / 2;
        var subHeight = this.height / 2;
        var levelPlus1 = this.level + 1;

        this.nodes[0] = new QuadTree(levelPlus1, this.x + subWidth, this.y, subWidth, subHeight);
        this.nodes[1] = new QuadTree(levelPlus1, this.x, this.y, subWidth, subHeight);
        this.nodes[2] = new QuadTree(levelPlus1, this.x, this.y + subHeight, subWidth, subHeight);
        this.nodes[3] = new QuadTree(levelPlus1, this.x + subWidth, this.y + subHeight, subWidth, subHeight);
      },
      getIndex : function(p){
        var x = p.pos.x;
        var y = p.pos.y;
        var radius = p.radius;
        var index = -1;
        var verticalMid = this.x + this.width/2;
        var horizontalMid = this.y + this.height/2;

        var topQuad = Boolean(y + radius < horizontalMid);
        var bottomQuad = Boolean(y - radius > horizontalMid);
        var leftQuad = Boolean(x + radius < verticalMid);
        var rightQuad = Boolean(x - radius > verticalMid);

        if(leftQuad){
          if(topQuad){
            index = 1;
          } else if (bottomQuad){
            index = 2;
          }
        } else if (rightQuad){
          if(topQuad){
            index = 0;
          } else if (bottomQuad){
            index = 3;
          }
        }
        return index;
      },
      insert : function(p){
        var index;
        if (this.nodes[0]) {
          index = this.getIndex(p);

          if (index != -1) {
            this.nodes[index].insert(p);

            return;
          }
        }

        this.objects[p.id] = p;
        this.count++;

        if (this.count > MAX_OBJECTS && this.level < MAX_LEVELS) {
          if (!this.nodes[0]) {
            this.split();
          }

          for(var i in this.objects){
            index = this.getIndex(this.objects[i]);
            if(index != -1){
              this.nodes[index].insert(this.objects[i]);
              delete this.objects[i];
              this.count--;
            }
          }
        }
      },
      retrieve : function(returnObjs, p){
        var index = this.getIndex(p);
        if(this.nodes[0]){
          if(index === -1){
            for(var i = 0, length = this.nodes.length; i < length; i++){
              this.nodes[i].retrieve(returnObjs, p);
            }
          } else {
            this.nodes[index].retrieve(returnObjs, p);
          }
        }

        for(var key in this.objects){
          returnObjs.push(this.objects[key]);
        }

        return returnObjs;
      }
    };

    return QuadTree;
  }());

  return Collision;

})(Behaviour);
